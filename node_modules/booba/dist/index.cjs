'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fetch = require('node-fetch');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

const MODS_ENUM = {
    NoFail: 1 << 0,
    Easy: 1 << 1,
    TouchDevice: 1 << 2,
    Hidden: 1 << 3,
    HardRock: 1 << 4,
    SuddenDeath: 1 << 5,
    DoubleTime: 1 << 6,
    Relax: 1 << 7,
    HalfTime: 1 << 8,
    Nightcore: 1 << 9,
    Flashlight: 1 << 10,
    Autoplay: 1 << 11,
    SpunOut: 1 << 12,
    Autopilot: 1 << 13,
    Perfect: 1 << 14,
    Key4: 1 << 15,
    Key5: 1 << 16,
    Key6: 1 << 17,
    Key7: 1 << 18,
    Key8: 1 << 19,
    FadeIn: 1 << 20,
    Random: 1 << 21,
    Cinema: 1 << 22,
    Target: 1 << 23,
    Key9: 1 << 24,
    KeyCoop: 1 << 25,
    Key1: 1 << 26,
    Key3: 1 << 27,
    Key2: 1 << 28,
    ScoreV2: 1 << 29,
    Mirror: 1 << 30
};

const MODS_SHORT_NAMES = {
    NoFail: 'NF',
    Easy: 'EZ',
    TouchDevice: 'TD',
    Hidden: 'HD',
    HardRock: 'HR',
    SuddenDeath: 'SD',
    DoubleTime: 'DT',
    Relax: 'RX',
    HalfTime: 'HT',
    Nightcore: 'NC',
    Flashlight: 'FL',
    Autoplay: 'AT',
    SpunOut: 'SO',
    Perfect: 'PF',
    Key4: '4K',
    Key5: '5K',
    Key6: '6K',
    Key7: '7K',
    Key8: '8K',
    FadeIn: 'FI',
    Random: 'RD',
    Cinema: 'CN',
    Target: 'TP',
    Key9: '9K',
    KeyCoop: 'KC',
    Key1: '1K',
    Key3: '3K',
    Key2: '2K',
    ScoreV2: 'V2',
    Mirror: 'MR'
};

const MODS_INHERITS = {
    Nightcore: 'DoubleTime',
    Perfect: 'SuddenDeath'
};

class Mods {
    constructor(mods_enabled) {
        if (typeof mods_enabled == 'number') {
            if (isNaN(mods_enabled)) {
                throw new Error("Invalid mods provided (NaN)");
            }

            this.value = mods_enabled;
        } else if (typeof mods_enabled == 'string') {
            this.value = this.fromString(mods_enabled);
        } else if (Array.isArray(mods_enabled)) {
            this.value = this.fromList(mods_enabled);
        } else {
            throw new Error("Invalid mods provided");
        }

        this.list = this.toList(this.value);
    }

    fromString(mods_string) {
        let mods_enabled = 0;

        let parts;

        mods_string = mods_string.toUpperCase();

        if (mods_string.startsWith('+')) {
            mods_string = mods_string.substring(1);
        }

        if (mods_string.includes(',')) {
            parts = mods_string.split(',');
        } else {
            parts = mods_string.match(/.{1,2}/g);
        }

        for (const [key, value] of Object.entries(MODS_SHORT_NAMES)) {
            if (parts.includes(value)) {
                mods_enabled |= MODS_ENUM[key];
            }
        }

        return mods_enabled;
    }

    fromList(mods_list) {
        let mods_enabled = 0;

        for (const mod of mods_list) {
            if (mod.length == 2) {
                for (const [key, value] of Object.entries(MODS_SHORT_NAMES)) {
                    if (value == mod.toUpperCase()) {
                        mods_enabled |= MODS_ENUM[key];
                    }
                }
            } else {
                if (MODS_ENUM[mod] != null) {
                    mods_enabled |= MODS_ENUM[mod];
                }
            }
        }

        return mods_enabled;
    }

    toList(mods_enabled) {
        const mods = [];

        for (const [mod, value] of Object.entries(MODS_ENUM)) {
            if (value > mods_enabled)
                break;

            if ((mods_enabled & value) == value) {
                mods.push(mod);
            }
        }

        return mods;
    }

    /**
     * 
     * @param {bool} with_plus Whether to output + at beginning of mods string
     */
    toString(with_plus = true) {
        if (this.list.length == 0) {
            return '';
        }

        let output_mods = [];

        for (const mod of this.list) {
            if (Object.keys(MODS_INHERITS).includes(mod)) {
                continue;
            }

            output_mods.push(MODS_SHORT_NAMES[mod]);            
        }

        return (with_plus ? '+' : '') + output_mods.join(',');
    }
}

class ppv2 {
    accuracy = 1.00;
    mods = [];
    mods_enabled = 0;
    #DIFF_MODS = [];
    #beatmap_api = "https://osu.lea.moe";

    constructor(params) {
        if (params.beatmap_api != null) {
            try {
                new URL(beatmap_api);

                this.beatmap_api = beatmap_api;
            } catch(e) {
                throw new Error("Not a valid URL");
            }
        }

        if (Array.isArray(params.diff_mods)) {
            this.#DIFF_MODS = params.diff_mods;
        }
    }

    /** 
     * Set beatmap
     * @param {string|number} beatmap_id
     * @returns {ppv2}
     */
    setBeatmap(beatmap_id) {
        this.beatmap_id = beatmap_id;

        return this;
    }

    async fetchBeatmap() {
        if (this.beatmap_id == null) {
            throw new Error("No Beatmap ID given");
        }

        try {
            const response = await fetch__default["default"](`${this.#beatmap_api}/b/${this.beatmap_id}?mode=${this.mode}`);
            const { beatmap, difficulty } = await response.json();

            return { beatmap, difficulty };
        } catch(e) {
            console.error(e);
            throw new Error("Failed fetching beatmap");
        }
    }

    async fetchDifficulty() {
        this.setDifficulty(await this.fetchBeatmap());
    }

    /**
     * Set mods.
     * @param {any} mods_enabled Mods
     * @returns {ppv2}
     */
    setMods(mods_enabled) {
        const mods = new Mods(mods_enabled);
        this.mods = mods.list;
        this.mods_enabled = mods.value ?? 0;

        // Only include Hidden in the diff_mods together with Flashlight
        if (mods.list.includes('Hidden') && !mods.list.includes('Flashlight')) {
            mods.list = mods.list.filter(m => m !== 'Hidden');
        }

        const diff_mods = new Mods(mods.list.filter(a => this.#DIFF_MODS.includes(a)));

        this.mods_enabled_diff = diff_mods.value ?? 0;

        return this;
    }
}

function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
}

class std_ppv2 extends ppv2 {
    mode = 0;

    constructor() {
        super({ diff_mods: ['TouchDevice', 'Hidden', 'HardRock', 'Easy', 'DoubleTime', 'HalfTime', 'Flashlight'] });
    }

    /**
     * Calculate accuracy
     * @returns {number}
     */
    computeAccuracy() {
        return Math.max(Math.min((this.n300 + this.n100 * 1/3 + this.n50 * 1/6)
        / this.totalHits(), 1), 0);
    }

    /**
     * Calculate total hits
     * @returns {number}
     */
    totalHits() {
        return this.n300 + this.n100 + this.n50 + this.nmiss;
    }

    /**
     * Calculate effective miss count with sliderbreaks
     * @returns {number}
     */
    effectiveMissCount() {
        let combo_based_miss_count = 0.0;

        if (this.map.nsliders > 0) {
            let full_combo_threshold = this.map.max_combo - 0.1 * this.map.nsliders;

            if (this.combo < full_combo_threshold) {
                combo_based_miss_count = full_combo_threshold / Math.max(1, this.combo);
            }
        }

        combo_based_miss_count = Math.min(combo_based_miss_count, this.n100 + this.n50 + this.nmiss);

        return Math.max(this.nmiss, combo_based_miss_count);
    }

    /**
     * Set player performance.
     * @param {Object} params Information about the play, can be osu! api response
     * @param {string} params.beatmap_id 
     * @param {number} params.count300 
     * @param {number} params.count100 
     * @param {number} params.count50 
     * @param {number} params.countmiss 
     * @param {number} params.maxcombo
     * @returns {std_ppv2}
     */
    setPerformance(params) {
        // osu! api v1 response
        if (params?.count300 != null) {
            if (params.beatmap_id != null) {
                this.beatmap_id = params.beatmap_id;
            }

            this.n300 = Number(params.count300);
            this.n100 = Number(params.count100);
            this.n50 = Number(params.count50);
            this.nmiss = Number(params.countmiss);
            this.combo = Number(params.maxcombo);

            this.setMods(Number(params.enabled_mods));
        }

        // osu! api v2 response
        else if (params?.statistics?.count_300 != null) {
            const { statistics } = params;

            this.beatmap_id = params?.beatmap?.id;
            this.n300 = statistics.count_300;
            this.n100 = statistics.count_100;
            this.n50 = statistics.count_50;
            this.nmiss = statistics.count_miss;
            this.combo = params.max_combo;
            
            this.setMods(params.mods);
        }
    
        this.total_hits = this.totalHits();
        this.accuracy = this.computeAccuracy();

        return this;
    }

    /**
     * Set the beatmap difficulty attributes
     * @param {object} params Information about the beatmap
     * @param {number} params.max_combo Maximum achievable combo
     * @param {number} params.aim Aim stars
     * @param {number} params.speed Speed stars
     * @param {number} params.total Total stars
     * @param {number} params.ar Approach Rate
     * @param {number} params.od Overall Difficulty
     * @param {number} params.count_circles Amount of hit circles
     * @param {number} params.count_sliders Amount of hit circles
     * @param {number} params.count_spinners Amount of hit circles
     * @returns {std_ppv2}
     */
    setDifficulty(params) {
        // beatmap api response
        if (params.beatmap != null && params.difficulty != null) {
            const { beatmap, difficulty } = params;

            const diff = difficulty[this.mods_enabled_diff];

            this.diff = {
                aim: diff.aim ?? 0,
                speed: diff.speed ?? 0,
                fl: diff.flashlight_rating ?? 0,
                total: diff.total ?? 0,
                slider_factor: diff.slider_factor ?? 1,
                speed_note_count: diff.speed_note_count ?? 0
            };

            this.map = {
                max_combo: diff.max_combo,
                ar: diff.ar,
                od: diff.od,
                ncircles: beatmap.num_circles ?? 0,
                nsliders: beatmap.num_sliders ?? 0,
                nspinners: beatmap.num_spinners ?? 0
            };
        } else {
            this.diff = {
                aim: params.aim,
                speed: params.speed,
                fl: params.fl ?? 0,
                total: params.total,
                slider_factor: params.slider_factor ?? 0,
                speed_note_count: params.speed_note_count ?? 0
            };

            this.map = {
                max_combo: params.max_combo,
                ar: params.ar,
                od: params.od,
                ncircles: params.count_circles ?? 0,
                nsliders: params.count_sliders ?? 0,
                nspinners: params.count_spinners ?? 0,
            };
        }

        this.n300 = this.map.ncircles + this.map.nsliders + this.map.nspinners - this.n100 - this.n50 - this.nmiss;
        this.total_hits = this.totalHits();

        return this;
    }

    /**
     * Compute aim skill pp
     * @returns {number}
     */
    computeAimValue() {
        const nmiss_e = this.effectiveMissCount();

        let value = Math.pow(5.0 * Math.max(1.0, this.diff.aim / 0.0675) - 4.0, 3.0) / 100000.0;

        let length_bonus = 0.95 + 0.4 * Math.min(1.0, this.total_hits / 2000.0) +
        (this.total_hits > 2000 ? Math.log10(this.total_hits / 2000.0) * 0.5 : 0.0);

        value *= length_bonus;

        if (nmiss_e > 0) {
            value *= 0.97 * Math.pow(1.0 - Math.pow(nmiss_e / this.total_hits, 0.775), nmiss_e);
        }

        if (this.map.max_combo > 0) {
            value *= Math.min(Math.pow(this.combo, 0.8) / Math.pow(this.map.max_combo, 0.8), 1.0);
        }

        let ar_factor = 0.0;

        if (this.map.ar > 10.33) {
            ar_factor += 0.3 * (this.map.ar - 10.33);
        } else if (this.map.ar < 8.0) {
            ar_factor += 0.05 * (8.0 - this.map.ar);
        }

        value *= 1.0 + ar_factor * length_bonus;

        if (this.mods.includes('Hidden')) {
            value *= 1.0 + 0.04 * (12.0 - this.map.ar);
        }

        const estimateDifficultSliders = this.map.nsliders * 0.15;

        if (this.map.nsliders > 0)
        {
            const estimateSliderEndsDropped = clamp(Math.min(this.n100 + this.n50 + this.nmiss, this.map.max_combo - this.combo), 0, estimateDifficultSliders);
            const sliderNerfFactor = (1 - this.diff.slider_factor) * Math.pow(1 - estimateSliderEndsDropped / estimateDifficultSliders, 3) + this.diff.slider_factor;
            value *= sliderNerfFactor;
        }

        value *= this.accuracy;

        value *= 0.98 + Math.pow(this.map.od, 2) / 2500.0;

        return value;
    }

    /**
     * Compute speed skill pp
     * @returns {number}
     */
    computeSpeedValue() {
        const nmiss_e = this.effectiveMissCount();

        let value = Math.pow(5.0 * Math.max(1.0, this.diff.speed / 0.0675) - 4.0, 3.0) / 100000.0;

        let length_bonus = 0.95 + 0.4 * Math.min(1.0, this.total_hits / 2000.0) +
            (this.total_hits > 2000 ? Math.log10(this.total_hits / 2000.0) * 0.5 : 0.0);
            
        value *= length_bonus;

        if (nmiss_e > 0) {
            value *= 0.97 * Math.pow(1.0 - Math.pow(nmiss_e / this.total_hits, 0.775), Math.pow(nmiss_e, 0.875));
        }

        if (this.map.max_combo > 0) {
            value *= Math.min(Math.pow(this.combo, 0.8) / Math.pow(this.map.max_combo, 0.8), 1.0);
        }

        let ar_factor = 0;

        if (this.map.ar > 10.33) {
            ar_factor += 0.3 * (this.map.ar - 10.33);
        }

        value *= 1.0 + ar_factor * length_bonus;

        if (this.mods.includes('Hidden')) {
            value *= 1.0 + 0.04 * (12.0 - this.map.ar);
        }

        let relevant_total_diff = this.total_hits - this.diff.speed_note_count;
        let relevant_count_great = Math.max(0, this.n300 - relevant_total_diff);
        let relevant_count_ok = Math.max(0, this.n100 - Math.max(0, relevant_total_diff - this.n300));
        let relevant_count_meh = Math.max(0, this.n50 - Math.max(0, relevant_total_diff - this.n300 - this.n100));
        let relevant_accuracy = this.diff.speed_note_count == 0 ? 0 : (relevant_count_great * 6.0 + relevant_count_ok * 2.0 + relevant_count_meh) / (this.diff.speed_note_count * 6.0);

        value *= (0.95 + Math.pow(this.map.od, 2) / 750) * Math.pow((this.accuracy + relevant_accuracy) / 2.0, (14.5 - Math.max(this.map.od, 8.0)) / 2);

        value *= Math.pow(0.99, this.n50 < this.total_hits / 500.0 ? 0.0 : this.n50 - this.total_hits / 500.0);

        return value;
    }

    /**
     * Compute acc skill pp
     * @returns {number}
     */
    computeAccValue() {
        let better_acc_percentage;
        let n_objects_with_acc;

        if (this.mods.includes('ScoreV2')) {
            n_objects_with_acc = this.total_hits;
            better_acc_percentage = this.accuracy;
        } else {
            n_objects_with_acc = this.map.ncircles;

            if (n_objects_with_acc > 0) {
                better_acc_percentage =  ((this.n300 - (this.total_hits - n_objects_with_acc)) * 6 + this.n100 * 2 + this.n50) / (n_objects_with_acc * 6);
            } else {
                better_acc_percentage = 0;
            }

            if (better_acc_percentage < 0) {
                better_acc_percentage = 0;
            }
        }

        let value = Math.pow(1.52163, this.map.od) * Math.pow(better_acc_percentage, 24) * 2.83;

        value *= Math.min(1.15, Math.pow(n_objects_with_acc / 1000.0, 0.3));

        if (this.mods.includes('Hidden')) {
            value *= 1.08;
        }

        if (this.mods.includes('Flashlight')) {
            value *= 1.02;
        }

        return value;
    }

    /**
     * Compute flashlight skill pp
     * @returns {number}
     */
    computeFlashlightValue() {
        let value = 0;

        if (!this.mods.includes('Flashlight')) {
            return value;
        }

        value = Math.pow(this.diff.fl, 2.0) * 25.0;

        if (this.nmiss > 0) {
            value *= 0.97 * Math.pow(1 - Math.pow(this.nmiss / this.total_hits, 0.775), Math.pow(this.nmiss, 0.875));
        }

        if (this.map.max_combo > 0) {
            value *= Math.min(Math.pow(this.combo, 0.8) / Math.pow(this.map.max_combo, 0.8), 1);
        }

        value *= 0.7 + 0.1 * Math.min(1.0, this.total_hits / 200.0) +
            (this.total_hits > 200 ? 0.2 * Math.min(1.0, (this.total_hits - 200) / 200.0) : 0.0);

        value *= 0.5 + this.accuracy / 2.0;

        value *= 0.98 + Math.pow(this.map.od, 2.0) / 2500.0;

        return value;
    }

    /**
     * Compute total pp from separate skills
     * @param {object} pp Object with pp values for all skills
     * @returns {number}
     */
    computeTotal(pp) {
        let multiplier = 1.14;

        if (this.mods.includes('NoFail')) {
            multiplier *= Math.max(0.9, 1.0 - 0.02 * this.effectiveMissCount());
        }

        if (this.mods.includes('SpunOut')) {
            multiplier *= 1.0 - Math.pow(this.map.nspinners / this.total_hits, 0.85);
        }

        return Math.pow(
            Math.pow(pp.aim, 1.1) +
            Math.pow(pp.speed, 1.1) +
            Math.pow(pp.fl, 1.1) +
            Math.pow(pp.acc, 1.1), 1.0 / 1.1
        ) * multiplier;
    }

    /**
     * Calculate pp and automatically fetch beatmap difficulty
     * @param {bool} fc Whether to simulate a full combo
     */
    async compute(fc = false) {
        if (this.diff?.total == null) {
            await this.fetchDifficulty();
        }

        const n300 = this.n300, nmiss = this.nmiss, combo = this.combo, accuracy = this.accuracy;

        if (fc) {
            this.n300 += this.nmiss;
            this.nmiss = 0;
            this.combo = this.map.max_combo;
            this.accuracy = this.computeAccuracy();
        }

        const pp = {
            aim: this.computeAimValue(),
            speed: this.computeSpeedValue(),
            fl: this.computeFlashlightValue(),
            acc: this.computeAccValue(),
            computed_accuracy: this.accuracy * 100
        };

        pp.total = this.computeTotal(pp);

        if (fc) {
            this.n300 = n300;
            this.nmiss = nmiss;
            this.combo = combo;
            this.accuracy = accuracy;

            this.pp_fc = pp;
        } else {
            this.pp = pp;
        }

        return pp;
    }
}

class taiko_ppv2 extends ppv2 {
    mode = 1;

    constructor() {
        super({ diff_mods: ['HardRock', 'Easy', 'DoubleTime', 'HalfTime'] });
    }

    /**
     * Calculate accuracy
     * @returns {number}
     */
    computeAccuracy() {
        return Math.max(Math.min((this.n100 * 1/2 + this.n300)
        / this.totalHits(), 1), 0);
    }

    /**
     * Calculate total hits
     * @returns {number}
     */
    totalHits() {
        if (!this.total_hits) {
            this.total_hits = this.n300 + this.n100 + this.n50 + this.nmiss;
        }

        return this.total_hits;
    }

    /**
     * Calculate total successful hits
     * @returns {number}
     */
    totalSuccessfulHits() {
        if (!this.total_successful_hits) {
            this.total_successful_hits = this.n300 + this.n100 + this.n50;
        }

        return this.total_successful_hits;
    }

    /**
     * Calculate effective miss count
     * @returns {number}
     */
    effectiveMissCount() {
        return Math.max(1.0, 1000.0 / this.totalSuccessfulHits()) * this.nmiss;
    }

    /**
     * Set player performance.
     * @param {Object} params Information about the play.
     * @param {number} params.count300 
     * @param {number} params.count100 
     * @param {number} params.count50 
     * @param {number} params.countmiss 
     */
    setPerformance(params) {
        // osu! api v1 response
        if (params?.count300 != null) {
            if (params.beatmap_id != null) {
                this.beatmap_id = params.beatmap_id;
            }

            this.n300 = Number(params.count300);
            this.n100 = Number(params.count100);
            this.n50 = Number(params.count50);
            this.nmiss = Number(params.countmiss);

            this.setMods(Number(params.enabled_mods));
        }

        // osu! api v2 response
        else if (params?.statistics?.count_300 != null) {
            const { statistics } = params;

            this.beatmap_id = params?.beatmap?.id;
            this.n300 = statistics.count_300;
            this.n100 = statistics.count_100;
            this.n50 = statistics.count_50;
            this.nmiss = statistics.count_miss;

            this.setMods(params.mods);
        }        

        this.total_hits = this.totalHits();
        this.accuracy = this.computeAccuracy();

        return this;
    }

    /**
     * Set the beatmap difficulty attributes.
     * @param {object} params Information about the beatmap
     * @param {number} params.total Total stars
     * @param {number} params.hit_window_300 300 hit window
     */
    setDifficulty(params) {
        // beatmap api response
        if (params.difficulty != null) {
            params = params.difficulty[this.mods_enabled_diff];
        }

        this.diff = { ...params };

        return this;
    }

    /**
     * Compute strain skill pp
     * @returns {number}
     */
    computeStrainValue() {
        let value = Math.pow(5 * Math.max(1.0, this.diff.total / 0.115) - 4.0, 2.25) / 1150.0;

        const lengthBonus = 1 + 0.1 * Math.min(1.0, this.totalHits() / 1500.0);

        value *= lengthBonus;
        value *= Math.pow(0.986, this.effectiveMissCount());

        if (this.mods.includes('Easy')) {
            value *= 0.985;
        }

        if (this.mods.includes('Hidden')) {
            value *= 1.025;
        }

        if (this.mods.includes('HardRock')) {
            value *= 1.050;
        }

        if (this.mods.includes('Flashlight')) {
            value *= 1.050 * lengthBonus;
        }

        value *= Math.pow(this.accuracy, 2.0);

        return value;
    }

    /**
     * Compute acc skill pp
     * @returns {number}
     */
    computeAccValue() {
        if (this.diff.hit_window_300 <= 0) {
            return 0;
        }

        let value
        = Math.pow(60.0 / this.diff.hit_window_300, 1.1) 
        * Math.pow(this.accuracy, 8.0) 
        * Math.pow(this.diff.total, 0.4) 
        * 27.0;

        const lengthBonus = Math.min(1.15, Math.pow(this.totalHits() / 1500.0, 0.3));
        value *= lengthBonus;

        if (this.mods.includes('Hidden') && this.mods.includes('Flashlight')) {
            value *= Math.max(1.050, 1.075 * lengthBonus);
        }

        return value;
    }

    /**
     * Compute total pp from separate skills
     * @param {object} pp Object with pp values for all skills
     * @returns {number}
     */
    computeTotal(pp) {
        let multiplier = 1.13;

        if (this.mods.includes('Hidden')) {
            multiplier *= 1.075;
        }

        if (this.mods.includes('Easy')) {
            multiplier *= 0.975;
        }        

        let value = Math.pow(
			Math.pow(pp.strain, 1.1) +
			Math.pow(pp.acc, 1.1), 1.0 / 1.1
		) * multiplier;

        return value;
    }

    /**
     * Calculate pp and automatically fetch beatmap difficulty
     * @param {bool} fc Whether to simulate a full combo
     */
    async compute(fc = false) {
        const n300 = this.n300, nmiss = this.nmiss, accuracy = this.accuracy;

        if (this.diff?.total == null) {
            await this.fetchDifficulty();
        }

        if (fc) {
            this.n300 += this.nmiss;
            this.nmiss = 0;
            this.accuracy = this.computeAccuracy();
        }

        const pp = {
            strain: this.computeStrainValue(),
            acc: this.computeAccValue(),
            computed_accuracy: this.accuracy * 100
        };

        pp.total = this.computeTotal(pp);

        if (fc) {
            this.n300 = n300;
            this.nmiss = nmiss;
            this.accuracy = accuracy;

            this.pp_fc = pp;
        } else {
            this.pp = pp;
        }

        return pp;
    }
}

class catch_ppv2 extends ppv2 {
    mode = 2;

    constructor() {
        super({ diff_mods: ['HardRock', 'Easy', 'DoubleTime', 'HalfTime'] });
    }

    /**
     * Calculate accuracy
     * @returns {number}
     */
    computeAccuracy() {
        return Math.max(Math.min((this.n50 + this.n100 + this.n300)
        / this.totalHits(), 1), 0);
    }

    /**
     * Calculate total hits
     * @returns {number}
     */
    totalHits() {
        if (!this.total_hits) {
            this.total_hits = this.n300 + this.n100 + this.n50 + this.nmiss + this.nkatu;
        }

        return this.total_hits;
    }

    /**
     * Calculate total object count
     * @returns {number}
     */
    totalComboHits() {
        if (!this.total_combo_hits) {
            this.total_combo_hits = this.n300 + this.n100 + this.nmiss;
        }

        return this.total_combo_hits;
    }

    /**
     * Set player performance.
     * @param {Object} params Information about the play.
     * @param {number} params.count300
     * @param {number} params.count100
     * @param {number} params.count50
     * @param {number} params.countmiss
     * @param {number} params.countkatu
     * @param {number} params.maxcombo
     */
    setPerformance(params) {
        // osu! api v1 response
        if (params?.count300 != null) {
            if (params.beatmap_id != null) {
                this.beatmap_id = params.beatmap_id;
            }

            this.n300 = Number(params.count300);
            this.n100 = Number(params.count100);
            this.n50 = Number(params.count50);
            this.nmiss = Number(params.countmiss);
            this.nkatu = Number(params.countkatu);
            this.combo = Number(params.maxcombo);

            this.setMods(Number(params.enabled_mods));
        }

        // osu! api v2 response
        else if (params?.statistics?.count_300 != null) {
            const { statistics } = params;

            this.beatmap_id = params?.beatmap?.id;
            this.n300 = statistics.count_300;
            this.n100 = statistics.count_100;
            this.n50 = statistics.count_50;
            this.nmiss = statistics.count_miss;
            this.nkatu = statistics.count_katu;
            this.combo = params.max_combo;

            this.setMods(params.mods);
        }

        this.total_hits = this.totalHits();
        this.accuracy = this.computeAccuracy();

        return this;
    }

    /**
     * Set the beatmap difficulty attributes.
     * @param {object} params Information about the beatmap
     * @param {number} params.total Total stars
     * @param {number} params.ar Approach rate
     * @param {number} params.max_combo Max combo
     */
    setDifficulty(params) {
        // beatmap api response
        if (params.difficulty != null) {
            params = params.difficulty[this.mods_enabled_diff];

            params.total = params.aim;
        }

        this.diff = { ...params };

        return this;
    }

    /**
     * Compute total pp
     * @returns {number}
     */
    computeTotal() {
        let value = Math.pow(5.0 * Math.max(1.0, this.diff.total / 0.0049) - 4.0, 2.0) / 100000.0;

        const lengthBonus =
		0.95 + 0.3 * Math.min(1.0, this.totalComboHits() / 2500.0) +
		(this.totalComboHits() > 2500 ? Math.log10(this.totalComboHits() / 2500.0) * 0.475 : 0.0);

        value *= lengthBonus;

        value *= Math.pow(0.97, this.nmiss);

        if (this.diff.max_combo > 0) {
            value *= Math.min(Math.pow(this.combo, 0.8) / Math.pow(this.diff.max_combo, 0.8), 1.0);
        }

        let approachRateFactor = 1.0;

        if (this.diff.ar > 9) {
            approachRateFactor += 0.1 * (this.diff.ar - 9.0);
        }

        if (this.diff.ar > 10) {
            approachRateFactor += 0.1 * (this.diff.ar - 10.0);
        }

        if (this.diff.ar < 8) {
            approachRateFactor += 0.025 * (8.0 - this.diff.ar); 
        }

        value *= approachRateFactor;

        if (this.mods.includes('Hidden')) {
            if (this.diff.ar <= 10) {
                value *= 1.05 + 0.075 * (10.0 - this.diff.ar);
            } else if (this.diff.ar > 10) {
                value *= 1.01 + 0.04 * (11.0 - Math.min(11.0, this.diff.ar));
            }
        }

        if (this.mods.includes('Flashlight')) {
            value *= 1.35 * lengthBonus;
        }

        value *= Math.pow(this.accuracy, 5.5);

        if (this.mods.includes('NoFail')) {
            value *= 0.90;
        }

        if (this.mods.includes('SpunOut')) {
            value *= 0.95;  
        }

        return value;
    }

    /**
     * 
     * @param {bool} fc Whether to simulate a full combo
     */
    async compute(fc = false) {
        if (this.diff?.total == null) {
            await this.fetchDifficulty();
        }

        const n300 = this.n300, nmiss = this.nmiss, combo = this.combo, accuracy = this.accuracy;

        if (fc) {
            this.n300 += this.nmiss;
            this.nmiss = 0;
            this.combo = this.diff.max_combo;
            this.accuracy = this.computeAccuracy();
        }

        const pp = {
            total: this.computeTotal(),
            computed_accuracy: this.accuracy * 100
        };

        if (fc) {
            this.n300 = n300;
            this.nmiss = nmiss;
            this.combo = combo;
            this.accuracy = accuracy;

            this.pp_fc = pp;
        } else {
            this.pp = pp;
        }

        return pp;
    }
}

class mania_ppv2 extends ppv2 {
    mode = 3;

    constructor() {
        const diff_mods = ['HardRock', 'Easy', 'DoubleTime', 'HalfTime'];

        for (let i = 1; i < 9; i++) {
            diff_mods.push(`Key${i}`);
        }

        super({ diff_mods });
    }

    /**
     * Calculate accuracy
     * @returns {number}
     */
    computeAccuracy() {
        return Math.max(Math.min((this.n300 + this.ngeki + this.nkatu * 2/3 + this.n100 * 1/3 + this.n50 * 1/6)
        / this.totalHits(), 1), 0);
    }

    computeCustomAccuracy() {
        if (this.totalHits() == 0) return 0;

        return (this.ngeki * 320 + this.n300 * 300 + this.nkatu * 200 + this.n100 * 100 + this.n50 * 50) 
        / (this.totalHits() * 320);
    }

    /**
     * Calculate total hits
     * @returns {number}
     */
    totalHits() {
        if (!this.total_hits) {
            this.total_hits = this.n300 + this.n100 + this.n50 + this.nmiss + this.ngeki + this.nkatu;
        }

        return this.total_hits;
    }

    /**
     * Calculate score without mod multipliers
     * @returns {number}
     */
    adjustedScore() {
        return this.score * (1.0 / this.diff.score_multiplier);
    }

    /**
     * Set player performance.
     * @param {Object} params Information about the play.
     * @param {number} params.count300
     * @param {number} params.count100
     * @param {number} params.count50
     * @param {number} params.countmiss
     * @param {number} params.countgeki
     * @param {number} params.countkatu
     * @param {number} params.score
     */
    setPerformance(params) {
        // osu! api v1 response
        if (params?.count300 != null) {
            if (params.beatmap_id != null) {
                this.beatmap_id = params.beatmap_id;
            }

            this.n300 = Number(params.count300);
            this.n100 = Number(params.count100);
            this.n50 = Number(params.count50);
            this.nmiss = Number(params.countmiss);
            this.ngeki = Number(params.countgeki);
            this.nkatu = Number(params.countkatu);
            
            this.setMods(Number(params.enabled_mods));
        }

        // osu! api v2 response
        else if (params?.statistics?.count_300 != null) {
            const { statistics } = params;

            this.beatmap_id = params?.beatmap?.id;
            this.n300 = statistics.count_300;
            this.n100 = statistics.count_100;
            this.n50 = statistics.count_50;
            this.nmiss = statistics.count_miss;
            this.nmiss = statistics.count_miss;
            this.ngeki = statistics.count_geki;
            this.nkatu = statistics.count_katu;

            this.setMods(params.mods);
        }

        this.score = Number(params.score);

        this.total_hits = this.totalHits();
        this.accuracy = this.computeAccuracy();

        return this;
    }

    /**
     * Set the beatmap difficulty attributes.
     * @param {object} params Information about the beatmap
     * @param {number} params.total Total stars
     * @param {number} params.hit_window_300 300 hit window
     * @param {number} params.score_multiplier Score multiplier
     */
    setDifficulty(params) {
        if (params.difficulty != null) {
            params = params.difficulty[this.mods_enabled_diff];
        }

        this.diff = { ...params };

        return this;
    }

    /**
     * Compute strain skill pp
     * @returns {number}
     */
    computeStrainValue() {
        const value = Math.pow(Math.max(this.diff.total -0.15, 0.05), 2.2)
                    * Math.max(0.0, 5.0 * this.computeCustomAccuracy() - 4.0)
                    * (1.0 + 0.1 * Math.min(1.0, this.totalHits() / 1500.0));

        return value;
    }

    /**
     * Compute total pp from separate skills
     * @param {object} pp Object with pp values for all skills
     * @returns {number}
     */
    computeTotal(pp) {
        let multiplier = 8.0;

        if (this.mods.includes('NoFail')) {
            multiplier *= 0.75;
        }

        if (this.mods.includes('SpunOut')) {
            multiplier *= 0.95;  
        }

        if (this.mods.includes('Easy')) {
            multiplier *= 0.50;
        }

        return pp.strain * multiplier;
    }

    /**
     * Calculate pp and automatically fetch beatmap difficulty
     */
    async compute() {
        if (this.diff?.total == null) {
            await this.fetchDifficulty();
        }

        const pp = {
            strain: this.computeStrainValue(),
            computed_accuracy: this.accuracy * 100
        };

        pp.total = this.computeTotal(pp);

        return pp;
    }
}

const CLIENT_SECRET_FORMAT = new RegExp('^[a-zA-Z0-9]{40}$');
const DEFAULT_HEADERS = {
    'Accept': 'application/json',
    'Content-Type': 'application/x-www-form-urlencoded',
    'x-api-version': '20240130'
};

class apiv2 {
    #apiBase = 'https://osu.ppy.sh';
    #clientId;
    #clientSecret;
    #token;
    /**
     * New apiv2 client 
     * @param {Object} params
     * @param {any} params.clientId Client ID
     * @param {string} params.clientSecret Client Secret
     * @param {string} [params.apiBase="https://osu.ppy.sh"] Base URL for API requests
     */
    constructor(params) {
        if (params.clientId == null) throw new Error('Client ID required.');
        if (params.clientSecret == null) throw new Error('Client Secret required.');

        if (isNaN(Number(params.clientId))) {
            throw new TypeError('Client ID has to be a number.');
        }

        if (!CLIENT_SECRET_FORMAT.test(params.clientSecret)) {
            throw new TypeError('Client Secret not a valid format.');
        }

        this.#clientId = params.clientId;
        this.#clientSecret = params.clientSecret;
    }

    /**
     * Check whether client has a valid bearer token
     * @returns {bool}
     */
    isAuthorized() {
        if (this.#token == null) return false;
        if (Date.now() > this.#token?.expiry) return false;

        return true;
    }

    /**
     * Get authorization headers
     * @returns {Object}
     */
    async getAuthorizationHeaders() {
        if (!this.isAuthorized()) {
            await this.obtainBearerToken();
        }

        return {
            ...DEFAULT_HEADERS,
            'Authorization': `Bearer ${this.#token.token}`
        };
    }

    /**
     * Obtains and sets bearer token
     */
    async obtainBearerToken() {
        const response = await fetch__default["default"](new URL('/oauth/token', this.#apiBase), {
            method: 'POST',
            headers: DEFAULT_HEADERS,
            body: new URLSearchParams({
                client_id: this.#clientId,
                client_secret: this.#clientSecret,
                grant_type: 'client_credentials',
                scope: 'public'
            }).toString()
        });

        const body = await response.json();

        this.#token = {
            token: body.access_token,
            expiry: Date.now() + body.expires_in * 1000
        };
    }

    /**
     * Fetch response from an APIv2 endpoint
     * @param {String} path The API path to 
     * @returns {Object}
     */
    async fetch(path, options) {
        const headers = {
            ...await this.getAuthorizationHeaders(),
            'Content-Type': 'application/json',
            ...options?.headers ?? {}
        };

        let params = '';

        if (options?.params) {
            const urlParams = new URLSearchParams(options.params);
            params = `?${urlParams}`;
        }

        const response = await fetch__default["default"](new URL('/api/v2' + path + params, this.#apiBase), {
            method: 'GET',
            headers
        });

        return await response.json();
    }
}

exports.Mods = Mods;
exports.apiv2 = apiv2;
exports.catch_ppv2 = catch_ppv2;
exports.mania_ppv2 = mania_ppv2;
exports.std_ppv2 = std_ppv2;
exports.taiko_ppv2 = taiko_ppv2;
